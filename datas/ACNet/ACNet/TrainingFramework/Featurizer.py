import torch as t
from TrainingFramework.ChemUtils import *
from TrainingFramework.Utils import *
import random
from Models.CMPNN.CMPNNFeaturizer import *
from torch_geometric.data import Data
from Models.Graphormer import algos

class BasicFeaturizer(object):
    # Featurizers are modules to generate input Tensors and Label Tensor of a given molecule.
    # For different predictive models, such as GCN, ATFP, FraGAT, CMPNN, the requirement of the input Tensors generated by featurizers are different.
    # So the users should implement and choose proper featurizer for their models.
    def __init__(self):
        super(BasicFeaturizer, self).__init__()

    def featurize(self, item):
        raise NotImplementedError(
            "Molecule Featurizer not implemented.")

class FPFeaturizer(BasicFeaturizer):
    # Featurizer to generate raw fingerprints of a given molecule
    def __init__(self, opt):
        super(FPFeaturizer, self).__init__()
        self.opt = opt
        self.MolFPCalculators = {
            'MorganFP' : MorganFPMolFPCalculator(),
            'RDKFP' : RDKFPMolFPCalculator(),
            'MACCSFP' : MACCSFPMolFPCalculator()
        }
        self.MolFPCalculator = self.MolFPCalculators[self.opt.args['MolFP']]

        # if using Morgan FP, radius and nBits should be set.
        if self.opt.args['MolFP'] == 'MorganFP':
            if 'radius' not in self.opt.args:
                raise KeyError(
                    'radius of the Morgan FP not given.'
                )
            elif 'nBits' not in self.opt.args:
                raise KeyError(
                    'nBits of the Morgan FP not given.'
                )
            else:
                self.FP_opt_array = {
                    'radius': self.opt.args['radius'],
                    'nBits': self.opt.args['nBits']
                }
        else:
            self.FP_opt_array = {}

    def featurize(self, item):
        SMILES = item['SMILES']
        value = item['Value']
        mol = GetMol(SMILES)
        FP = self.MolFPCalculator.CalculateFP(mol, self.FP_opt_array)
        FP = t.Tensor(FP)

        label = self.GetLabelFromValues(value)

        return FP, label

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label

class SMILESTokenFeaturizer(BasicFeaturizer):
    def __init__(self, opt):
        super(SMILESTokenFeaturizer, self).__init__()
        self.opt = opt
        self.SMILESdict = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
         '#', '%', '(', ')', '+', '-', '.', '/', '=', '@', '[', '\\', ']',
         'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',
         'V', 'W', 'X', 'Y', 'Z',
         'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
         'v', 'w', 'x', 'y', 'z',
                           'STA', 'END', 'PAD']
        self.MaxDictLength = len(self.SMILESdict)
        opt.set_args('MaxDictLength',self.MaxDictLength)

    def prefeaturize(self, dataset):
        max_len = 0
        for item in dataset:
            cur_len = len(item['SMILES'])
            if cur_len > max_len:
                max_len = cur_len
        self.MaxSMILESLength = max_len

    def featurize(self, item):
        SMILES = item['SMILES']
        Value = item['Value']
        Label = self.GetLabelFromValues(Value)
        TokenVector = self.SMILES2indexvector(SMILES)
        return TokenVector, Label


    def SMILES2indexvector(self, SMILES):
        TokenVector = []
        TokenVector.append(self.token2index('STA'))
        for token in SMILES:
            TokenVector.append(self.token2index(token))
        TokenVector.append(self.token2index('END'))
        while(len(TokenVector) < self.MaxSMILESLength+2):
            TokenVector.append(self.token2index('PAD'))
        assert len(TokenVector) == self.MaxSMILESLength + 2
        TokenVector = t.Tensor(TokenVector).long()
        return TokenVector

    def token2index(self, token):
        loc = self.SMILESdict.index(token)
        return loc

    def token2onehot(self, token):
        vector = t.zeros(self.MaxDictLength)
        loc = self.SMILESdict.index(token)
        vector[loc] = 1
        return vector

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label

class GraphFeaturizer(BasicFeaturizer):
    # Featurizer used for naive GCN model to generate AdjMat, FeatureMat and Label
    def __init__(self):
        super(GraphFeaturizer, self).__init__()

    def featurize(self, item):
        SMILES = item['SMILES']
        Value = item['Value']
        mol = GetMol(SMILES)
        AdjMat = GetAdjMat(mol)
        FeatureMat = GetMolFeatureMat(mol)
        AdjMat = t.Tensor(AdjMat)
        FeatureMat = t.Tensor(FeatureMat)
        Label = self.GetLabelFromValues(Value)

        # The naive GCN cannot be used for a graph with isolated nodes
        # Those nodes that are not connected with other nodes should be disgard.
        # This trick may not be correct, it should be checked latter.
        ids = self.zero_degree_check(AdjMat)
        AdjMat = t.index_select(AdjMat, dim=0, index=ids)
        AdjMat = t.index_select(AdjMat, dim=1, index=ids)
        FeatureMat = t.index_select(FeatureMat, dim=0, index=ids)

        return (AdjMat, FeatureMat), Label

    def zero_degree_check(self, AdjMat):
        # to find out that which node is isolated
        # ids is the index of the nodes of which the degree is not zero.
        degree = t.sum(AdjMat, dim=1)
        ids = [i for i,x in enumerate(degree) if x != 0]
        ids = t.Tensor(ids).long()
        return ids

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label

class PyGACGraphFeaturizer(BasicFeaturizer):
    # Featurizer used for PyGGNNs, to generate a PyG.Data object from a given SMILES item.
    def __init__(self, opt):
        super(PyGACGraphFeaturizer, self).__init__()
        self.opt = opt

    def featurize(self, item):
        SMILES1 = item['SMILES1']
        SMILES2 = item['SMILES2']
        Value = item['Value']
        mol1 = GetMol(SMILES1)
        EdgeList1 = t.Tensor(GetEdgeList(mol1, bidirection = True)).long()
        AtomFeatureMat1 = t.Tensor(GetMolFeatureMat(mol1))
        BondFeatureMat1 = t.Tensor(GetBondFeatureMat(mol1, bidirection = True))
        atomnum1 = mol1.GetNumAtoms()

        mol2 = GetMol(SMILES2)
        EdgeList2 = t.Tensor(GetEdgeList(mol2, bidirection = True, offset=atomnum1)).long()
        AtomFeatureMat2 = t.Tensor(GetMolFeatureMat(mol2))
        BondFeatureMat2 = t.Tensor(GetBondFeatureMat(mol2, bidirection = True))
        AtomFeatureMat = t.cat([AtomFeatureMat1, AtomFeatureMat2], dim=0)
        EdgeList = t.cat([EdgeList1, EdgeList2], dim=0)
        BondFeatureMat = t.cat([BondFeatureMat1, BondFeatureMat2], dim=0)
        Label = self.GetLabelFromValues(Value)
        # generate masks
        AtomNum1 = AtomFeatureMat1.size()[0]
        BondNum1 = BondFeatureMat1.size()[0]
        AtomNum2 = AtomFeatureMat2.size()[0]
        BondNum2 = BondFeatureMat2.size()[0]
        # AtomMask1 = t.zeros(AtomNum1).long()
        # AtomMask2 = t.ones(AtomNum2).long()
        # BondMask1 = t.zeros(BondNum1).long()
        # BondMask2 = t.ones(BondNum2).long()
        # AtomMask = t.cat([AtomMask1, AtomMask2])
        # BondMask = t.cat([BondMask1, BondMask2])
        data = Data(x=AtomFeatureMat, edge_index = EdgeList.t().contiguous(), y = Label.t(), edge_attr = BondFeatureMat, atom_num = t.Tensor([AtomNum1, AtomNum2]).long(), bond_num = t.Tensor([BondNum1, BondNum2]).long())#atom_mask = AtomMask, bond_mask = BondMask)
        assert data.is_undirected()
        return data

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label

class GraphormerFeaturizer(BasicFeaturizer):
    def __init__(self, max_node, multi_hop_max_dist, spatial_pos_max,opt):
        super(GraphormerFeaturizer, self).__init__()
        self.max_node = max_node
        self.multi_hop_max_dist = multi_hop_max_dist
        self.spatial_pos_max = spatial_pos_max
        self.opt = opt
        # self.offset = self.opt.args['num_offset']

    def featurize(self, item):
        '''
        original data in Graphormer
        edge_index: [2, num_edges], node index of each edge
        edge_attr: [num_edges, 3], edge feature
        x: [num_nodes, 9], node feature
        y: [num_graphs, 1], graph label
        '''
        SMILES = item['SMILES']
        mol = GetMol(SMILES)
        Value = item['Value']
        label = self.GetLabelFromValues(Value)
        # Calculate the original data
        # node feature, size:[num_nodes, 39], calculated by the feature function in ChemUtils.py
        # edge feature, size:[num_edges, 10]
        # edge index, size:[2,num_edges]
        # directed edge
        # todo(zqzhang): updated in GBv1
        if self.opt.args['FeatureCategory'] == 'BaseOH':
            x, edge_attr = GetBaseFeatureOH(mol)
        elif self.opt.args['FeatureCategory'] == 'BaseED':
            x, edge_attr = GetBaseFeatureED(mol)
        elif self.opt.args['FeatureCategory'] == 'OGB':
            x, edge_attr = GetOGBFeature(mol)
        elif self.opt.args['FeatureCategory'] == 'RichOH':
            x, edge_attr = GetRichFeatureOH(mol)
        elif self.opt.args['FeatureCategory'] == 'RichED':
            x, edge_attr = GetRichFeatureED(mol)
        else:
            raise NotImplementedError('No feature category.')
        x = t.Tensor(x).long()
        edge_attr = t.Tensor(edge_attr).long()

        edge_index = t.Tensor(GetEdgeList(mol, bidirection = True)).long().t()

        N = x.size(0)
        x = self.convert_to_single_emb(x)
        # each element of x correspond to a token,which will be embedded into a single vector by nn.Embedding.

        # node adj matrix [N, N] bool
        adj = torch.zeros([N, N], dtype=torch.bool)
        adj[edge_index[0, :], edge_index[1, :]] = True

        # edge feature here
        if len(edge_attr.size()) == 1:
            print("Call! Call! Call! Find edge_attr with size == 1!!!")
            print(f"edge_attr: {edge_attr}")
            edge_attr = edge_attr[:, None]
        # edge_attr should be [num_edge, bond_feature_size].

        attn_edge_type = torch.zeros([N, N, edge_attr.size(-1)], dtype=torch.long)
        # attn_edge_type: [node_num, node_num, bond_feature_size]
        # A tensor for what?

        # print(edge_index[0,:])
        # print(edge_index[1,:])
        # print(attn_edge_type[edge_index[0, :], edge_index[1, :]])
        # print(self.convert_to_single_emb(edge_attr) + 1)
        attn_edge_type[edge_index[0, :], edge_index[1, :]
        ] = self.convert_to_single_emb(edge_attr) + 1
        # attn_edge_type records the edge_attr with offset.
        # for each edge ( [edge_index[0,:], edge_index[1,:] ), the edge_attr is converted to a embed with offset
        # and plus 1 (why?)
        # Other [i,j], for no edge between i,j, the attr remains zeros.

        shortest_path_result, path = algos.floyd_warshall(adj.numpy())
        # Calculate and return the SPD of nodes in adj.
        # shortest_path_result is the distance of each node pairs.
        # shortest_path_result: [node_num, node_num]
        # path: [node_num, node_num]
        # for path[i,j] = k(long), it indicates that if a traveler wants to go from i to j
        # it should firstly go to k, then travel from k to j.

        max_dist = np.amax(shortest_path_result) # largest distance of SP, which indicates the N in eq.7.
        edge_input = algos.gen_edge_input(max_dist, path, attn_edge_type.numpy())
        # edge_input: [node_num, node_num, max_dist(N), edge_feat_num]
        # edge_input just stores the edge_attrs of all of the edges passing from node i to node j.
        # it is a list.

        # print(f"attn_edge_type[0,1]: {attn_edge_type[0,1,:]}")
        # print(f"attn_edge_type[1,2]: {attn_edge_type[1,2,:]}")
        # print(f"attn_edge_type[0,2]: {attn_edge_type[0,2,:]}")
        # print(f"edge_input[0,2,:]: {edge_input[0,2,:,:]}")
        # raise RuntimeError

        spatial_pos = torch.from_numpy((shortest_path_result)).long()
        # the SPD value, Phi(vi, vj)in eq.6. [node_num, node_num]
        attn_bias = torch.zeros(
            [N + 1, N + 1], dtype=torch.float)  # with graph token
        # attn_bias is initially created with [node_num+1, node_num+1]
        # i.e. A_{ij}

        in_degree = adj.long().sum(dim=1).view(-1)
        out_degree = adj.long().sum(dim=0).view(-1)
        edge_input = torch.from_numpy(edge_input).long()

        return [x,
                adj,
                attn_bias,
                attn_edge_type,
                spatial_pos,
                in_degree,
                out_degree,
                edge_input,
                label]

    def convert_to_single_emb(self, x):
        offset = self.opt.args['num_offset']
        feature_num = x.size(1) if len(x.size()) > 1 else 1
        feature_offset = 1 + \
                         torch.arange(0, feature_num * offset, offset, dtype=torch.long)
        x = x + feature_offset
        return x

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)
        # todo(zqzhang): updated in TPv7.8
        label = label.t().contiguous()

        return label

    def GetEdgeIndex(self, mol):
        edge_list = []
        for bond in mol.GetBonds():
            i = bond.GetBeginAtomIdx()
            j = bond.GetEndAtomIdx()
            edge_list.append((i, j))
            edge_list.append((j, i))
        edge_index = np.array(edge_list, dtype = np.int64).T
        return edge_index

class CMPNNFeaturizer(BasicFeaturizer):
    # Featurizer to calculate Input Tensors of the CMPNN model
    def __init__(self, opt):
        super(CMPNNFeaturizer, self).__init__()
        self.opt = opt

    def featurize(self, item):
        SMILES = item['SMILES']
        Value = item['Value']
        Label = self.GetLabelFromValues(Value)

        return SMILES, Label

    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label

class PretrainFeatureFeaturizer(BasicFeaturizer):
    def __init__(self, opt):
        super(PretrainFeatureFeaturizer, self).__init__()
        self.opt = opt

    def featurize(self, item):
        Feature = item['Feature']
        Feature = t.Tensor(Feature)
        Value = item['Value']

        if (self.opt.args['ExpName'] == 'Tox21') or (self.opt.args['ExpName'] == 'Toxcast'):
            for i in range(len(Value)):
                value = Value[i]
                if np.isnan(value):
                    Value[i] = -1

        Label = self.GetLabelFromValues(Value)
        return Feature, Label


    def GetLabelFromValues(self, values):
        label = []
        if self.opt.args['ClassNum'] == 1:
            if self.opt.args['TaskNum'] == 1:
                label.append(float(values))
            else:
                for v in values:
                    label.append(float(v))
            label = t.Tensor(label)
        else:
            for v in values:
                label.append(int(v))
            label = t.Tensor(label).long()
        label.unsqueeze_(-1)

        return label





#########################################################################
# Test Codes
#########################################################################